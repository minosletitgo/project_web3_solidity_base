#### 概念
- 最小代理（```Minimal Proxy```）是一种轻量级的代理合约模式，通常用于以低成本的方式部署多个功能相同的合约实例。
- 它通过利用代理模式和克隆技术来节省 Gas 费用，特别适用于需要部署大量相似合约的场景。
- 相关标准：ERC-1167 标准（也称为“克隆合约”或“最小代理标准”），定义了最小代理的字节码模板。
- 类似于传统代理（透明代理、通用可升级代理）的逻辑结构，但一般认为是"不可升级的"。

#### 典型字节码
- ERC-1167 标准定义了一个固定的字节码（约45字节）模板，用于创建一个最小代理合约。
- 极低的部署成本（约 22,000 Gas）。
- 这个字节码会将所有调用通过 ```delegatecall``` 转发到指定的实现合约地址。
- 以下是典型的字节码（以十六进制表示）：
```
    3d602d80600a3d3981f3363d3d373d3d3d363d73<实现合约地址>5af43d82803e903d91602b57fd5bf3
    
    前半部分是初始化代码，用于设置代理逻辑。
    <实现合约地址> 是逻辑合约的 20 字节地址。
    后半部分通过 delegatecall 将调用转发到逻辑合约。
```

#### 字节码拆分解析
```
    初始化代码：3d602d80600a3d3981f3
    这部分是代理合约的前导代码，负责初始化运行时逻辑。它实际上是运行时代码的一部分，用于设置上下文。
    作用：
        将后续的字节码（从偏移量 0x0a 开始，长度 0x2d）复制到内存。
        返回这段代码作为代理合约的运行时代码。
        这部分代码在部署时执行一次，设置代理的逻辑。
    ///////////////////////////////////////////////////////////        
    3d          // RETURNDATASIZE (推送返回数据大小到栈顶，通常为 0)
    60 2d       // PUSH1 0x2d (推送 0x2d，即运行时代码的长度)
    80          // DUP1 (复制栈顶的值)
    60 0a       // PUSH1 0x0a (推送 0x0a，即运行时代码的偏移量)
    3d          // RETURNDATASIZE (再次推送 0)
    39          // CODECOPY (将字节码从偏移量 0x0a 复制到内存，长度为 0x2d)
    81          // DUP2 (复制栈顶第二个值，即 0x2d)
    f3          // RETURN (返回内存中 0 到 0x2d 的代码作为运行时代码)    
    
    
    代理逻辑：363d3d373d3d3d363d73
    这部分是运行时代码的核心，负责将调用转发到实现合约地址。
    作用：
        CALLDATACOPY：将 msg.data（调用数据）复制到内存，为 delegatecall 做准备。
        多次使用 RETURNDATASIZE（值为 0）作为占位符，设置内存偏移量和参数。
        PUSH20：准备推送实现合约地址（接下来的 20 字节）。    
    ///////////////////////////////////////////////////////////        
    36          // CALLDATASIZE (推送调用数据的大小到栈顶)
    3d          // RETURNDATASIZE (推送 0)
    3d          // RETURNDATASIZE (再次推送 0)
    37          // CALLDATACOPY (将调用数据复制到内存，从 0 开始)
    3d          // RETURNDATASIZE (推送 0)
    3d          // RETURNDATASIZE (推送 0)
    3d          // RETURNDATASIZE (推送 0)
    36          // CALLDATASIZE (推送调用数据大小)
    3d          // RETURNDATASIZE (推送 0)
    73          // PUSH20 (接下来 20 字节是实现合约地址) 
    
    
    实现合约地址：implementation
    这是一个 20 字节的地址（implementation），在运行时被硬编码到字节码中。
    在 PUSH20 操作码后，EVM 会将这 20 字节作为实现合约地址推送到栈顶。
    作用：
        指定 delegatecall 的目标合约地址。
        
    
    代理调用逻辑：5af43d82803e903d91602b57fd5bf3
    这部分完成 delegatecall 调用并处理返回结果。
    作用：
        DELEGATECALL：使用剩余 Gas 调用实现合约，输入为 msg.data，输出存储在内存中。
        检查 delegatecall 的成功标志（0 或 1）。
        如果失败（成功标志为 0），使用 REVERT 回滚并返回错误数据。
        如果成功，跳转到 JUMPDEST，使用 RETURN 返回结果数据。        
    ///////////////////////////////////////////////////////////
    5a          // GAS (推送剩余 Gas)
    f4          // DELEGATECALL (执行 delegatecall，参数：gas, 地址, 输入偏移, 输入大小, 输出偏移, 输出大小)
    3d          // RETURNDATASIZE (推送返回数据大小)
    82          // DUP3 (复制栈顶第三个值，即 delegatecall 的成功标志)
    80          // DUP1 (复制栈顶值，即返回数据大小)
    3e          // RETURNDATACOPY (将返回数据复制到内存)
    90          // SWAP1 (交换栈顶两个值)
    3d          // RETURNDATASIZE (推送返回数据大小)
    91          // SWAP2 (交换栈顶和第三个值)
    60 2b       // PUSH1 0x2b (推送 0x2b，跳转目标)
    57          // JUMPI (如果 delegatecall 成功，跳转到 0x2b)
    fd          // REVERT (如果 delegatecall 失败，触发 revert)
    5b          // JUMPDEST (跳转目标，成功时的逻辑)
    f3          // RETURN (返回内存中的返回数据)                 
```

#### 完整字节码的作用
- 拼接后的完整字节码（约 55 字节）会在部署时：
  - 执行初始化代码（```3d602d80600a3d3981f3```），将后续代码作为运行时代码返回。
  - 运行时代码（从 ```363d3d373d3d3d363d73``` 开始）会在代理合约运行时处理所有调用：
    - 复制 ```msg.data```。
    - 通过 ```delegatecall``` 调用实现合约。
    - 根据调用结果返回数据或回滚。

#### 字节码的特点
```
    最小化 Gas 成本：
        部署合约的 Gas 成本与字节码长度成正比，ERC-1167 的字节码被优化到极短（45 字节 + 地址）。
        使用内联汇编直接生成字节码，避免 Solidity 编译器的冗余代码。
    
    硬编码地址：
        实现合约地址被直接嵌入字节码，省去存储槽的使用（存储槽读写 Gas 成本高）。
        这也意味着代理合约不可升级，除非重新部署。
    
    通用性：
        字节码模板是固定的，只需替换 20 字节的 implementation 地址即可适配任何逻辑合约。
        工厂合约通过 abi.encodePacked 动态拼接字节码，灵活生成代理。
    
    EVM 优化：
        使用 RETURNDATASIZE（值为 0）作为占位符，减少操作码数量。
        通过 JUMPI 和 JUMPDEST 实现条件分支，处理 delegatecall 的成功/失败情况。
```

#### 等效的合约代码
```
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.20;
    
    contract MinimalProxy {
        // 逻辑合约地址
        address private immutable implementation;
    
        constructor(address _implementation) {
            implementation = _implementation;
        }
    
        // 回退函数，将所有调用委托给逻辑合约
        fallback() external payable {
            address impl = implementation;
            assembly {
                // 复制调用数据
                calldatacopy(0, 0, calldatasize())
                // 执行 delegatecall
                let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
                // 复制返回值
                returndatacopy(0, 0, returndatasize())
                // 根据 delegatecall 结果返回或抛出错误
                switch result
                case 0 { revert(0, returndatasize()) }
                default { return(0, returndatasize()) }
            }
        }
    
        // 支持接收 ETH
        receive() external payable {}
    }
```

#### 部署者工厂
```
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.20;
    
    contract MiniProxyFactory {
        event ProxyCreated(address indexed proxyAddress, address indexed implementation);
    
        function createProxy(address implementation) external returns (address) {
            // 验证实现合约地址
            require(implementation.code.length > 0, "Invalid implementation address");
    
            // 拼接字节码
            bytes memory bytecode = abi.encodePacked(
                hex"3d602d80600a3d3981f3363d3d373d3d3d363d73",
                implementation,
                hex"5af43d82803e903d91602b57fd5bf3"
            );
    
            // 部署代理合约
            address proxy;
            assembly {
                proxy := create(0, add(bytecode, 0x20), mload(bytecode))
                if iszero(proxy) { revert(0, 0) }
            }
    
            // 触发事件
            emit ProxyCreated(proxy, implementation);
            return proxy;
        }
    }
```

#### 部署者工厂(使用```OpenZeppelin```的克隆库)
```
    import "@openzeppelin/contracts/proxy/Clones.sol";
    
    contract ProxyFactory {
        function createProxy(address implementation) external returns (address) {
            return Clones.clone(implementation);
        }
    }

    ////////////////////// Clones.clone源码如下：//////////////////////
    
    function clone(address implementation, uint256 value) internal returns (address instance) {
        if (address(this).balance < value) {
            revert Errors.InsufficientBalance(address(this).balance, value);
        }
        assembly ("memory-safe") {
            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes
            // of the `implementation` address with the bytecode before the address.
            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))
            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.
            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))
            instance := create(value, 0x09, 0x37)
        }
        if (instance == address(0)) {
            revert Errors.FailedDeployment();
        }
    }
```
