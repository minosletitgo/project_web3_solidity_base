

#### 理解数字签名的含义：
##### 准备消息：用户A需要对一条消息（如，交易数据(金额，地址)，某个链上事件的签名确认，投票意图）进行签名，确保它是由自己发出的。
##### 签名方式1：用户A使用自己的私钥结合ethers.Wallet，对这条消息进行签名，生成一个"独特的数据"。该"独特的数据"证明消息确实是由用户A发出的。
##### 签名方式2：用户A调取指定钱包(如 MetaMask、欧易钱包)API，请求把这条消息进行签名，生成一个"独特的数据"。该"独特的数据"证明消息确实是由用户A发出的。
##### 拆分签名：通常为了节约链上资源(gas费)，该拆分签名的行为，一般发生在链下(即，应用层)。当然，也可以发生在链上(即，下一个步骤，智能合约层)。
##### 发送信息：用户A将原始消息和生成的"独特的数据"一起发送给目标程序（例如智能合约）。
##### 验证：目标程序接收到信息后，解析得出用户A的地址来验证签名。如果验证成功，程序就可以确认这是用户A的真实意图，放心地执行相关操作。
------------------------------------------------------------------------------------------------------------------------

#### 数字签名的主要特征：
##### 身份验证：只有拥有消息对应私钥的用户才能生成有效的签名，这确保了签名者的身份是真实的。
##### 数据完整性：如果消息内容被修改，即使签名保持不变，验证过程也会失败。因此，数字签名保证了消息的完整性，即签名的数据内容没有被篡改。
##### 不可否认性：由于签名是使用私钥生成的，而私钥只有签名者拥有，因此一旦签名生成，签名者不能否认自己曾经签署该消息。这一点在合约和法律场景中尤其重要，签名者的行为具有法律效力。
##### 防止重放攻击：数字签名通常与独特的消息（如时间戳或随机数）结合使用，防止重放攻击。
##### 效率高：数字签名的验证是基于公钥密码学的数学原理，这使得验证过程在确保安全的同时，也非常快速。
##### 去中心化安全性：数字签名不依赖中心化的信任机构，而是依赖公钥密码学。

------------------------------------------------------------------------------------------------------------------------

#### 数字签名的主要使用场景：
##### 身份验证：用户登录去中心化应用（DApp）时，不需要密码，而是通过数字签名确认用户是某个钱包的拥有者。DApp会生成一条消息让用户签名，验证成功后允许用户执行某些操作。
##### 多重签名钱包：多重签名钱包要求多个用户签名确认交易才能执行。签名可以确保交易由正确的参与者批准，增加了资金的安全性。多重签名钱包经常用于企业级资金管理。
##### 离线消息签名：在某些情况下，用户可能需要离线签名某些交易或数据，并将签名后的数据上传到链上执行。通过这种方式，可以避免高昂的链上存储费用。
##### 交易授权：授权转账操作，例如，一方希望授权另一方在一定条件下从其地址转账，授权方会提供签名，接收方根据该签名执行转账操作。
##### 链下数据的验证：智能合约通常用于处理链下数据的验证。例如，预言机（Oracles）将链下数据传入区块链时，可以使用签名来确保数据的来源可靠，并且没有被篡改。
##### 零知识证明：零知识证明协议中的许多场景需要数字签名来确保证明者身份，并确保信息传递过程中的数据完整性。
##### 委托/代理交易：在DeFi协议中，数字签名可以用于用户授权代理进行某些操作，比如在Uniswap上签名批准代理进行交易操作，而不需要用户亲自发起交易。

------------------------------------------------------------------------------------------------------------------------

#### 示例 签名方式1：
##### 用户A进行一次投票行为，假设他为一个候选人ID=12345的人，进行投票

- 完整合约如下 TestVoting.sol：
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./utils/Strings.sol"; // 引入自定义的 Strings 库

contract TestVoting {
    event VerifyVoteLog(bool success, address voter, address recoveredAddress);

    function verifyVote(
        address voter, // 投票用户的地址
        string memory message, // 投票消息
        uint8 v, // 签名的 v 值
        bytes32 r, // 签名的 r 值
        bytes32 s // 签名的 s 值
    ) public returns (bool) {
        // 直接将消息处理为以太坊签名的消息
        bytes32 ethSignedMessageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(bytes(message).length), message)
        );

        // 从签名数据恢复出签名者的地址
        address recoveredAddress = ecrecover(ethSignedMessageHash, v, r, s);
        // 比较恢复出的地址和提供的用户地址
        bool success = (recoveredAddress == voter);

        emit VerifyVoteLog(success, voter, recoveredAddress);

        return success;
    }
}
```

- 使用hardhat部署这个投票合约，nodejs代码如下，deployTestVoting.js
```
const hre = require("hardhat");
const logger = require('../srcs/logger');

async function main() {
    const [deployer] = await hre.ethers.getSigners();
    logger.info(`Deploying contracts with the account: ${deployer.address}`);

    const TestVoting = await hre.ethers.getContractFactory("TestVoting", { contractPath: "./contracts/TestVoting.sol" });
    //const TestVoting = await hre.ethers.getContractFactory("TestVoting");
    const testVoting = await TestVoting.deploy();
    await testVoting.deployed();
    logger.info(`Contract deployed to: ${testVoting.address}`);
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
```

- 部署成功后，使用nodejs模拟用户A的行为，如下，runTestVoting.js
```
const hre = require("hardhat");
const logger = require("../srcs/logger");
const contractABI = require("../abi/TestVoting.json");
const assert = require("assert");
require("dotenv").config();

async function main() {
  const candidateId = "12345"; // 候选人的ID
  const message = `I vote for candidate ${candidateId}`; // 投票的消息

  const privateKey = process.env.PRIVATE_KEY_localGanache;
  const wallet = new hre.ethers.Wallet(privateKey);

  try {
    // 签名消息
    const signature = await wallet.signMessage(message);

    // 拆分签名数据
    const { r, s, v } = hre.ethers.utils.splitSignature(signature);

    const userAddress = wallet.address;

    const [signer] = await ethers.getSigners();
    const signerAddress = await signer.getAddress();
    assert.strictEqual(signerAddress, userAddress);

    // 已经部署完毕的，投票合约的地址
    const contractAddress = "0x24320D020dC25241C3d1a38404bf4e4CbEDD9250"; 
    const abi = contractABI;

    // 创建智能合约实例
    const contract = new hre.ethers.Contract(contractAddress, abi, signer);

    // 调用智能合约的投票验证方法
    const tx = await contract.verifyVote(userAddress, message, v, r, s);
    const contractReceipt = await tx.wait(); // 等待交易打包进区块
    // 有效监控交易数据
    for (const event of contractReceipt.events) {
      logger.info(JSON.stringify(event, null, 2));
    }
    logger.info(`交易发送成功：", ${tx}`);
  } catch (error) {
    logger.error(`签名失败：", ${error}`);
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```
- hardhat控制台日志，如下：
```
PS F:\project_web3\project_contract_development_more_tests\project_web3_pure_deploy> npx hardhat run .\test\runTestVoting.js --network localGanache
2024-10-11 20:46:09 [info]: {
  "transactionIndex": 0,
2024-10-11 20:46:09 [info]: {
  "transactionIndex": 0,
  "blockNumber": 100,
  "blockNumber": 100,
  "transactionHash": "0x2dc217ad4c486edec110a0402751fa4d5392beab14044813729ad57a2781a856",
  "transactionHash": "0x2dc217ad4c486edec110a0402751fa4d5392beab14044813729ad57a2781a856",
  "address": "0x24320D020dC25241C3d1a38404bf4e4CbEDD9250",
  "address": "0x24320D020dC25241C3d1a38404bf4e4CbEDD9250",
  "topics": [
    "0x164629908c0aca8f9ff0399564fb33be5f7658ea82bb0d5a4136bfef40c30423"
  "topics": [
    "0x164629908c0aca8f9ff0399564fb33be5f7658ea82bb0d5a4136bfef40c30423"
  ],
  "data": "0x0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000352307e6d885976d25b780f2af1f519084f6b2e7000000000000000000000000352307e6d885976d25b780f2af1f519084f6b2e7",
  "logIndex": 0,
  "blockHash": "0x536d7a7d4b23c252aa17c3976e64e700ce62cc803d7bb060e1d68b2340611377",
  "blockHash": "0x536d7a7d4b23c252aa17c3976e64e700ce62cc803d7bb060e1d68b2340611377",
  "args": [
  "args": [
    true,
    true,
    "0x352307e6d885976D25B780f2af1F519084F6b2E7",
    "0x352307e6d885976D25B780f2af1F519084F6b2E7"
  ],
  "event": "VerifyVoteLog",
  "eventSignature": "VerifyVoteLog(bool,address,address)"
}
2024-10-11 20:46:09 [info]: 交易发送成功：", [object Object]
```
- 可以看到日志中 VerifyVoteLog的监控，返回true

