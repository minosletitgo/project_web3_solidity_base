Solid       | adj   |   坚硬的，可靠的
Solidity    | n     |   硬度，可靠性

EVM：Ethereum Virtual Machine：以太坊虚拟机
--它是一个图灵完备的虚拟计算机，能够执行以太坊智能合约。

// SPDX-License-Identifier: MIT
--Massachusetts Institute of Technology, 简称MIT
--开源许可证，但它要求保留版权声明和许可证声明，
--它是Github上使用率最高的许可证
--它最初由麻省理工学院开发和使用

// SPDX-License-Identifier: Unlicense
--许可证表示代码没有任何版权限制，任何人都可以自由使用

// SPDX-License-Identifier: Apache-2.0
--一个宽松的开源许可证，允许用户自由使用、修改和分发软件，同时提供了对贡献者的保护。
--它要求对源代码的修改和分发包括原始许可证和版权声明，以及任何修改的说明。Apache 2.0 也提供了专利权利的保障。

// SPDX-License-Identifier: GPL-2.0-or-later
--一种强制开源许可证，要求所有基于 GPL 许可的软件修改版和衍生版也必须以 GPL 许可证发布。
--or-later 表示该软件也可以在 GPL 的任何后续版本下发布。

// SPDX-License-Identifier: GPL-3.0-or-later
--相比于 GPL-2.0，它在版权和专利方面提供了更多的保护。
--or-later 表示该软件也可以在 GPL 的任何后续版本下发布。

选择和使用 SPDX 标识符的原因
--明确许可证要求: 使用 SPDX 标识符可以清晰地表明代码的许可证类型，有助于避免法律纠纷和合规问题。
--自动化工具: SPDX 标识符支持工具和自动化流程（如许可证合规扫描），帮助开发人员更容易管理和维护代码库中的许可证信息。
--项目标准: 在开源项目中，明确的许可证声明是良好的实践，有助于社区理解和遵守许可证条款。


HEX，英文全称 Hexadecimal，表示十六进制。
DEC，英文全称 Decimal，表示十进制。
OCT，英文全称 Octal，表示八进制。
BIN，英文全称 Binary，表示二进制。


指定编译器版本的指令
pragma solidity 0.8.0;                  精确版本
pragma solidity >=0.8.0 <0.9.0;         版本范围
pragma solidity ^0.8.0;                 向后兼容的版本(等价于上一条)
pragma solidity >=0.0.0;                任意版本(不推荐)
pragma solidity ^0.7.0 || ^0.8.0;       多个版本范围

------------------------------------------------------------------------------------------------------------------------------------------

值类型（Value Types）完全统计：
--布尔型（bool）
--整数型（int 和 uint）
--地址型（address）（20 字节）
--定长字节型（bytes1 到 bytes32）（1个字节 到 32个字节）
--枚举型（enum）（起始值 0）

引用类型（Reference Types）完全统计：
--动态大小的字节数组（bytes）
--字符串（string）
--数组（array）：固定长度数组（Fixed-size Arrays）、动态长度数组（Dynamic-size Arrays）
--结构体（struct）
--映射（mapping）
--合约（contract）

constant说明(统称：常量)：
--在编译时必须赋值(即，声明的时候)
--读取时，几乎不消耗 gas
--适用：如数学常量、固定的配置值等

immutable说明(统称：不变量)：
--在编译时必须赋值(即，声明的时候)，在合约部署时赋值(即，构造函数)；必须是二者取其一!
--读取时，消耗 gas
--适用：如合约的初始化参数、合约的部署地址等



------------------------------------------------------------------------------------------------------------------------------------------

整数类型细说：
--不论uint或者int【8位 ~ 256位】【使用字节对齐的方式位数值是8/16/24/32/40/48/56/64/72/80/88/96...........256】【粗暴理解为8的倍数值】
--占位字节数【1 ~ 32】

uint
--取值范例【0 ~ 1111 1111】
--取值【0 ~ 2^Bit -1】
--如【0 ~ 2^8 -1】即【0 ~ 255】

int(建议复习一下计算机的补码原理)
--取值范例【1111 1111 , 0111 1111】
--取值【-1*(2^(Bit-1)) ~ 2^(Bit-1) -1】
--如【-1*(2^7) ~ 2^7 -1】即【-128 ~ 127】

地址类型细说：
--20字节值
--十六进制字符的每一位都可以表示 16 种不同的值，而 4 位二进制数据也可以表示 16 种不同的值（0 到 15）；每1位个十六进制字符代表4位个二进制
--1个字节 = 8位个二进制数
--20个字节 = 8*20位个二进制数 = 8*20/4位个二进制数 = 40位个十六进制数
--如，0x1234567890123456789012345678901234567890，十六进制表达方式，即40个值

定长字节型细说：
bytes32 public _byte32 = "MiniSolidity";
--"MiniSolidity"的长度是11个字符。每个字符在UTF-8编码中占用1个字节，所以总长度是11字节。
--"MiniSolidity" + 21个零字节
--4d696e69536f6c69646974790000000000000000000000000000000000000000

枚举类型细说：
--底层类型是 uint（无符号整数）所以，即使显性的赋值，也不得小于0
    enum Status {
        Invalid = -1,   // 编译错误: 值必须是无符号整数
        InIdle          // 默认值为0
        InProgress      // 1
        InPause = 5     // 5
        InEnd           // 6
    }

------------------------------------------------------------------------------------------------------------------------------------------

动态大小的字节数组细说：
--bytes是一个更通用的动态字节数组，可以存储任意字节数据。
--bytes dynamicBytes = "Hello, Solidity!";

字符串细说：
--string是bytes的一个子类型
--string 是一种动态长度的 Unicode(UTF-8编码) 字符串，用于存储文本数据。
--string 是 bytes 的一个特殊形式，专门用于处理文本。
--string message = "Hello, Solidity!";

数组类型细说：
--uint[3] fixedSizeArray = [1, 2, 3];
--uint[] dynamicArray; dynamicArray.push(1); dynamicArray.push(2); dynamicArray.push(3);

映射（mapping）类型细说：
--必须存储在storage中
--不储存任何键（Key）的资讯，也没有length的资讯，故，不支持迭代或获取键的集合，只能通过键快速访问值
--主键只能是值类型（如 uint、address 等），而值可以是任意类型，包括引用类型。

------------------------------------------------------------------------------------------------------------------------------------------

函数形式：
function <function name>(<parameter types>) {internal|external|public|private} [pure|view|payable] [returns (<return types>)]

函数可见性：
public：内部和外部均可见。
private：只能从本合约内部访问，继承的合约也不能使用。
external：只能从合约外部访问（但内部可以通过 this.f() 来调用，f是函数名，但这种调用方式消耗gas较多，不推荐）。
internal: 只能从合约内部访问，继承的合约可以用。

函数权限(功能关键字)：
payable：可支付
pure：纯净(不读不写)
view：纯读

变量的存储位置(顺带介绍)：
storage：存储在链上
memory：存储在内存中
calldata：存储在内存中(一般修饰函数的参数，但不可更改它)

函数形式示例：
    function foo() public {
        //Nothing
    }

    function foo() public pure {
        //Nothing
    }

    function foo() public pure returns(uint) {
        return 1;
    }

    function foo() public pure returns(uint ret) {
        ret = 1;
    }

    function foo() public pure returns(uint ret) {
        return  1;
    }       

必须使用memory的情形：
--函数的参数(或返回值)，如果是string、bytes 数组
--函数体内，使用 new 关键字创建数组

函数体内，创建结构体struct
Person memory newPerson = new Person({...});    是过时的语法，Solidity 0.8.x以前的版本使用
Person memory newPerson = Person({...});        是推荐的语法，Solidity 0.8.x以及之后的版本使用
Person memory newPerson = Person(...);          是推荐的语法，Solidity 0.8.x以及之后的版本使用

固定长度数组的声明(同时初始化，可选)：
uint[8] array0;
uint[3] array1 = [uint(1), 2, 3];   //如果不强转1，可能会编译不通过
bytes1[5] array2;
address[100] array3;

动态长度数组的声明(不可能同时初始化)：
uint[] array4;
bytes1[] array5;
address[] array6;
bytes array7;                       //bytes比较特殊，是数组，但是不用加[]

数组的成员(变量，以及函数)
--length            长度
--push(x)           动态数组尾部添加元素
--pop()             动态数组末尾移除最后一个元素，并返回该元素
--delete ary[index] 把指定元素重置为默认值
--delete ary        动态长度数组，把指定元素重置为默认值，数组长度变为0
--delete ary        固定长度数组，把指定元素重置为默认值，数组长度不变化

------------------------------------------------------------------------------------------------------------------------------------------

控制流(不展开了)：
    if(_number == 0){
        //..
    }else{
        //..
    }

    for(uint i = 0; i < 10; i++){
        //..
    }

    while(i < 10){
        //..
        i++;
    }
    
    do{
        //..
        i++;
    } while(i < 10);    

三元运算符：
    // return the max of x and y
    return x >= y ? x: y; 

------------------------------------------------------------------------------------------------------------------------------------------

几种异常：

require：
--solidity 0.8版本之前抛出异常的常用方法，缺点就是gas随着描述异常的字符串长度增加，比error命令要高
--失败时消耗部分 gas：如果条件为假，交易将回滚并恢复到调用之前的状态，退还剩余的 gas，并可以返回自定义错误消息。
--适用：业务常规检查判断(通常用于验证输入、权限检查等)
--控制台的异常定位，比较明显
--require(amount > 0, "Amount must be greater than zero");
--require(amount > 0);

assert：
--类似于require，但不能传入描述字符串
--失败时消耗所有 gas：如果条件为假，交易将回滚并消耗所有剩余的 gas。
--适用：逻辑检查判断(通常用于检测代码中的严重错误和不变量违反、不应发生的错误)
--控制台的异常定位，不明显
--assert(result >= a);

revert：
--用于终止执行并回滚状态，可以选择返回错误消息。
--失败时消耗所有 gas：使用字符串参数，自然消耗gas多
--适用：复杂逻辑回滚、自定义错误处理
--总 gas 消耗 = 基础消耗（约 21,000 gas） + 字符长度 * 每字符消耗（约 68 gas）。
--控制台的异常定位，比较明显
--revert("Failed to send Ether");

error：
--solidity 0.8.4版本新增，高效省gas，抛出异常
--更加节省 gas：在触发时不会消耗过多的 gas，并且可以带有参数来提供更多的上下文信息，必须搭配revert一起，所以具备回滚特性
--控制台的异常定位，比较明显
--error TransferNotOwner();                 // 自定义error
--error TransferNotOwner(address sender);   // 自定义的带参数的error
--revert TransferNotOwner();                // revert出

------------------------------------------------------------------------------------------------------------------------------------------

修饰器（modifier）：

modifier onlyOwner {
   require(msg.sender == owner); // 检查调用者是否为owner地址
   _; // 如果是的话，继续运行函数主体；
}

------------------------------------------------------------------------------------------------------------------------------------------

事件（Events）：
--是太坊虚拟机上日志的抽象
--在太坊虚拟机上，是比较经济的存储数据的方式，每个大概消耗2,000 gas；相比之下，链上存储一个新变量至少需要20,000 gas
--可以通过客户端（如 Web3.js 或 Ethers.js）进行监听和检索(如，交易的完成、数据的更新等)
--参数可以带有indexed关键字，他们会保存在以太坊虚拟机日志的topics中，方便之后检索。

------------------------------------------------------------------------------------------------------------------------------------------

库合约（library）：
--为了提升Solidity代码的复用性和减少gas而存在。
--封装可重用的代码逻辑，使得不同的合约可以共享相同的代码，而无需将代码重复写入每一个合约中。
--是一系列的函数合集，由大神或者项目方创作。
--99%的开发者都不需要自己去写库合约，会用大神写的就可以了。


1.利用using for指令
--指令using A for B;可用于附加库合约（从库 A）到任何类型（B）。
--添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。
--注意：在调用的时候，这个变量会被当作第一个参数传递给函数：

using Strings for uint256;
function getString1(uint256 _number) public pure returns(string memory){
    // 库合约中的函数会自动添加为uint256型变量的成员
    return _number.toHexString();
}

2.通过库合约名称调用函数(更直观接近于传统编程范式，不绕口)
function getString2(uint256 _number) public pure returns(string memory){
    return Strings.toHexString(_number);
}


常用的库合约有：
Strings：将uint256转换为String
Address：判断某个地址是否为合约地址
Create2：更安全的使用Create2 EVM opcode
Arrays：跟数组相关的库合约

------------------------------------------------------------------------------------------------------------------------------------------

import引入文件：

通过文件相对位置引用
import './XXXX.sol';

通过网址引用
import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol';

通过npm的目录引入
import '@openzeppelin/contracts/utils/math/Math.sol';



------------------------------------------------------------------------------------------------------------------------------------------