#### 概念：
- 在以太坊等区块链平台上，Gas费用直接影响用户体验和合约的执行成本。
- 所以，开发者需要运用(起码是熟知)以下优化技巧。

　

### 1. 减少存储操作：
- 减少```storage```读写：```storage```是最昂贵的操作之一，尽量将数据存储在```memory```中并一次性写入```memory```，减少对```memory```的[多次]读写。
```
pragma solidity ^0.8.0;

contract GasOptimization {
    uint[] public data;
    
    // 优化前：函数做多次对 storage 数据的写入
    function processData(uint[] memory inputData) public {
        for (uint i = 0; i < inputData.length; i++) {
            data.push(inputData[i]);
        }
    }

    // 优化后：将数据存储在 memory 中，处理完成后一次性写入 storage
    function processData(uint[] memory inputData) public {
        uint length = inputData.length;
        uint[] memory tempData = new uint[](length);
        
        for (uint i = 0; i < length; i++) {
            tempData[i] = inputData[i];
        }
        
        // 一次性将数据写入 storage
        data = tempData;
    }    
}
```
- 使用```calldata```避免不必要的拷贝到```memory```中：
- 1. ```calldata```是一个用于函数输入参数的特殊数据位置，它是只读的，并且不进行数据拷贝。
- 2. 对于函数的输入参数，特别是数组和字符串类型，如果我们不需要修改它们，可以使用```calldata```来减少内存的使用和数据复制的成本。
```
pragma solidity ^0.8.0;

contract GasOptimization {

    // 优化前：使用 memory 来存储输入参数
    function processData(uint[] memory inputData) public pure returns (uint) {
        uint sum = 0;
        for (uint i = 0; i < inputData.length; i++) {
            sum += inputData[i];
        }
        return sum;
    }

    // 优化后：使用 calldata 来避免不必要的拷贝
    function processData(uint[] calldata inputData) public pure returns (uint) {
        uint sum = 0;
        for (uint i = 0; i < inputData.length; i++) {
            sum += inputData[i];
        }
        return sum;
    }    
}

```

　

### 2. 合理使用数据类型：
- 小数据类型可以考虑打包：
- 1. 一个```storage```变量是按照32字节(256位)进行存储的，因此每次写入和读取时，会以 32 字节为单位分配内存。
- 2. 如果你有多个小的数据类型(如，uint8、 bool等)，它们的实际存储需求远小于32字节，但是如果不进行打包，它们可能会分别占用不同的32字节存储单元，导致不必要的空间浪费和gas开销。
- 3. 参考：将多个小数据类型打包到一个 uint256 中，可以显著减少存储空间的浪费。
```
pragma solidity ^0.8.0;

// 优化前
contract GasOptimization {
    uint8 public var1;
    uint8 public var2;
    uint8 public var3;
    bool public flag1;
    bool public flag2;

    function setData(uint8 _var1, uint8 _var2, uint8 _var3, bool _flag1, bool _flag2) public {
        var1 = _var1;
        var2 = _var2;
        var3 = _var3;
        flag1 = _flag1;
        flag2 = _flag2;
    }
}

// 优化后
contract GasOptimization {
    uint256 public packedData;

    // 设置数据，使用位运算将多个值打包到一个 uint256 中
    function setData(uint8 _var1, uint8 _var2, uint8 _var3, bool _flag1, bool _flag2) public {
        packedData = uint256(_var1) << 248 | uint256(_var2) << 240 | uint256(_var3) << 232 | 
                     uint256(_flag1 ? 1 : 0) << 224 | uint256(_flag2 ? 1 : 0) << 223;
    }

    // 获取数据
    function getData() public view returns (uint8, uint8, uint8, bool, bool) {
        uint8 var1 = uint8(packedData >> 248);
        uint8 var2 = uint8(packedData >> 240);
        uint8 var3 = uint8(packedData >> 232);
        bool flag1 = (packedData >> 224) & 1 == 1;
        bool flag2 = (packedData >> 223) & 1 == 1;
        return (var1, var2, var3, flag1, flag2);
    }
}
```
- 选择合适的数据类型
- 1. 选择合适的数据类型不仅能节省存储空间，还能避免不必要的溢出和浪费。
- 2. 根据变量的实际范围来选择数据类型。例如，如果一个变量的取值范围不大，选择一个较小的类型(如，uint8或uint16)，而不是uint256会更节省gas。
```
pragma solidity ^0.8.0;

// 优化前
contract GasOptimization {
    uint256 public balance; // 不需要这么大的类型
    uint256 public count;   // 不需要这么大的类型

    function setBalanceAndCount(uint256 _balance, uint256 _count) public {
        balance = _balance;
        count = _count;
    }
}

// 优化后
contract GasOptimization {
    uint16 public balance; // 使用合适的类型
    uint16 public count;   // 使用合适的类型

    function setBalanceAndCount(uint16 _balance, uint16 _count) public {
        balance = _balance;
        count = _count;
    }
}
```