#### 概念：
- Gas是用来度量以太坊虚拟机（EVM）执行操作所需的计算资源的单位。
- 每次执行一段代码（如交易、智能合约方法调用或状态更新），都会消耗一定数量的Gas。
- Gas是通过以太坊的原生货币——以太币（ETH）来支付的。每个操作的Gas费用乘以相应的Gas价格（以Gwei为单位）就构成了实际的费用。
- ```Gas费用 = Gas消耗量 × Gas价格```
- Gas价格（通常以Gwei为单位，1 Gwei = 10^-9 ETH）是由交易发起者设置的，可以根据网络的拥堵情况调整。
- Gas价格越高，交易被矿工（或验证者）处理的速度就越快。
- Gas的消耗量是由EVM预定义的，开发者无法直接控制，但可以优化智能合约的代码以减少Gas的使用。
- 在以太坊等区块链平台上，Gas费用直接影响用户体验和合约的执行成本。
- Gas Limit：这是交易或合约调用时允许消耗的最大Gas量。如果执行过程中Gas消耗超过了这个上限，交易或操作将被撤销，且已消耗的Gas不会退还。
- Gas Price：这是用户愿意为每单位Gas支付的ETH数量。Gas价格越高，交易越有可能被矿工优先处理。
- Gas作用1：防止滥用：Gas机制防止了不必要的资源浪费或恶意攻击（例如无限循环）。如果智能合约中有
- Gas作用2：激励机制：Gas费用作为矿工或验证者的奖励，激励他们处理交易和执行智能合约操作。
- Gas波多因素1：网络拥堵：当以太坊网络繁忙时，Gas费用会上升，因为更多的人争夺相同的区块空间。反之，在网络不繁忙时，Gas费用较低。
- Gas波多因素2：合约复杂度：复杂的智能合约操作需要更多Gas来执行，因此会提高费用。


　

### 1. 减少存储操作：
- 减少```storage```读写：```storage```是最昂贵的操作之一，尽量将数据存储在```memory```中并一次性写入```memory```，减少对```memory```的[多次]读写。
```
pragma solidity ^0.8.0;

contract GasOptimization {
    uint[] public data;
    
    // 优化前：函数做多次对 storage 数据的写入
    function processData(uint[] memory inputData) public {
        for (uint i = 0; i < inputData.length; i++) {
            data.push(inputData[i]);
        }
    }

    // 优化后：将数据存储在 memory 中，处理完成后一次性写入 storage
    function processData(uint[] memory inputData) public {
        uint length = inputData.length;
        uint[] memory tempData = new uint[](length);
        
        for (uint i = 0; i < length; i++) {
            tempData[i] = inputData[i];
        }
        
        // 一次性将数据写入 storage
        data = tempData;
    }    
}
```
- 使用```calldata```避免不必要的拷贝到```memory```中：
- 1. ```calldata```是一个用于函数输入参数的特殊数据位置，它是只读的，并且不进行数据拷贝。
- 2. 对于函数的输入参数，特别是数组和字符串类型，如果我们不需要修改它们，可以使用```calldata```来减少内存的使用和数据复制的成本。
```
pragma solidity ^0.8.0;

contract GasOptimization {

    // 优化前：使用 memory 来存储输入参数
    function processData(uint[] memory inputData) public pure returns (uint) {
        uint sum = 0;
        for (uint i = 0; i < inputData.length; i++) {
            sum += inputData[i];
        }
        return sum;
    }

    // 优化后：使用 calldata 来避免不必要的拷贝
    function processData(uint[] calldata inputData) public pure returns (uint) {
        uint sum = 0;
        for (uint i = 0; i < inputData.length; i++) {
            sum += inputData[i];
        }
        return sum;
    }    
}

```

　

### 2. 合理使用数据类型：
- 小数据类型可以考虑打包：
- 1. 一个```storage```变量是按照32字节(256位)进行存储的，因此每次写入和读取时，会以 32 字节为单位分配内存。
- 2. 如果你有多个小的数据类型(如，uint8、 bool等)，它们的实际存储需求远小于32字节，但是如果不进行打包，它们可能会分别占用不同的32字节存储单元，导致不必要的空间浪费和gas开销。
- 3. 参考：将多个小数据类型打包到一个 uint256 中，可以显著减少存储空间的浪费。
```
pragma solidity ^0.8.0;

// 优化前
contract GasOptimization {
    uint8 public var1;
    uint8 public var2;
    uint8 public var3;
    bool public flag1;
    bool public flag2;

    function setData(uint8 _var1, uint8 _var2, uint8 _var3, bool _flag1, bool _flag2) public {
        var1 = _var1;
        var2 = _var2;
        var3 = _var3;
        flag1 = _flag1;
        flag2 = _flag2;
    }
}

// 优化后
contract GasOptimization {
    uint256 public packedData;

    // 设置数据，使用位运算将多个值打包到一个 uint256 中
    function setData(uint8 _var1, uint8 _var2, uint8 _var3, bool _flag1, bool _flag2) public {
        packedData = uint256(_var1) << 248 | uint256(_var2) << 240 | uint256(_var3) << 232 | 
                     uint256(_flag1 ? 1 : 0) << 224 | uint256(_flag2 ? 1 : 0) << 223;
    }

    // 获取数据
    function getData() public view returns (uint8, uint8, uint8, bool, bool) {
        uint8 var1 = uint8(packedData >> 248);
        uint8 var2 = uint8(packedData >> 240);
        uint8 var3 = uint8(packedData >> 232);
        bool flag1 = (packedData >> 224) & 1 == 1;
        bool flag2 = (packedData >> 223) & 1 == 1;
        return (var1, var2, var3, flag1, flag2);
    }
}
```
- 选择合适的数据类型
- 1. 选择合适的数据类型不仅能节省存储空间，还能避免不必要的溢出和浪费。
- 2. 根据变量的实际范围来选择数据类型。例如，如果一个变量的取值范围不大，选择一个较小的类型(如，uint8或uint16)，而不是uint256会更节省gas。
```
pragma solidity ^0.8.0;

// 优化前
contract GasOptimization {
    uint256 public balance; // 不需要这么大的类型
    uint256 public count;   // 不需要这么大的类型

    function setBalanceAndCount(uint256 _balance, uint256 _count) public {
        balance = _balance;
        count = _count;
    }
}

// 优化后
contract GasOptimization {
    uint16 public balance; // 使用合适的类型
    uint16 public count;   // 使用合适的类型

    function setBalanceAndCount(uint16 _balance, uint16 _count) public {
        balance = _balance;
        count = _count;
    }
}
```