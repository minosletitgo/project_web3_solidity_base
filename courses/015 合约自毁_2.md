## ✅ 什么是 selfdestruct / SELFDESTRUCT

* 在传统 (历史) Solidity / EVM 中，`selfdestruct(address payable recipient)` 用于“销毁”合约：将该合约账户中所有剩余的以太 (Ether) 发送到 `recipient` 指定的地址。然后合约的代码 (bytecode) 和存储 (storage) 会被移除 — 从链上删除。 ([Alchemy][1])
* 换句话说，调用 `selfdestruct` 后，该地址不再是一个可执行合约 — 它不再有状态、代码或逻辑。 ([密碼龐克 Cypherpunks Taiwan][2])
* 这是由 EVM 层的 `SELFDESTRUCT` opcode 实现的。 ([evm.codes][3])

---

## 📚 为何设计 / 曾经为何使用 selfdestruct

使用 `selfdestruct` 的常见场景／动机包括：

* **清理不再使用或废弃的合约** — 当合约功能过时、不再需要时，用来移除占用链上存储和状态的合约。 ([Alchemy][1])
* **快速转移合约中剩余的 ETH** — 在合约结束时，将所有 ETH 转移到指定地址（例如所有者钱包）。 ([solidity-by-example.org][4])
* **智能合约升级** — 比如开发者希望废弃旧合约、部署新合约，用 `selfdestruct` 清除旧合约，以旧合约资金迁移到新合约或开发者控制地址。 ([Alchemy][1])
* **应对紧急情况 / 安全漏洞** — 如果部署的合约有重大漏洞或不可修复的问题，通过 `selfdestruct` 可作为“安全出口”：销毁合约、防止漏洞被继续利用。 ([Alchemy][1])

---

## ⚠️ 风险、问题与变化 — 为什么对它变得谨慎 / 弃用

虽然 `selfdestruct` 很强大，但是也引入了不少风险 + 已经随着以太坊发展而被限制／弃用。主要包括：

* **安全风险 — 被滥用 / 利用为攻击载体**

    * 恶意合约可以使用 `selfdestruct` 将 ETH 强制发送到任意地址（甚至其他合约）， bypass 接收合约的 fallback/receive 限制。 ([腾讯云][5])
    * 如果合约提供了公开的 `destroy`/`selfdestruct` 接口，而没有权限控制 (例如只有 owner 能调用)，任何人都可能触发合约销毁，导致功能中断或资产损失。 ([CSDN][6])
    * 即使在合约被销毁后，如果仍有代码或应用错误地将 ETH 发送到该地址，这些 ETH 会被锁住 — 因为已无合约逻辑处理转账。 ([Fellowship of Ethereum Magicians][7])
* **破坏代码不可变性与信任模型**

    * 因为合约部署后一般被认为是“immutable（不可改变）”，`selfdestruct` 是唯一能真正改变/删除合约代码的 EVM opcode。这个能力破坏了以太坊合约的一大假设。 ([hackmd.io][8])
    * 这对依赖合约地址长期稳定行为 (比如库合约、代理合约、地址白名单) 的系统构成风险。历史上就有因为库合约被 `selfdestruct`，导致整个系统不可用的案例。 ([hackmd.io][8])
* **以太坊协议 / EVM 行为的更改 — selfdestruct 已被弱化 / 弃用**

    * 根据最新官方文档，自从 EVM 达到 “Cancun” 及之后版本，`selfdestruct` 的行为发生了变化：它**将只发送该账户中所有 ETH 给指定地址，但 *不再销毁* 合约**。也就是说，合约代码与存储不会被删除，仅仅是 ETH 被转移。 ([docs.soliditylang.org][9])
    * 此变化源于为了未来存储结构 (如使用 Verkle 树) 的兼容性考虑。 ([Ethereum Stack Exchange][10])
    * 与此同时，在 Solidity 编译器 (从 0.8.18 版) 中，`selfdestruct` 已被标记为 **弃用 (deprecated)**，并建议开发者避免在新合约中使用它。 ([docs.soliditylang.org][9])

---

## 📄 从官方 / 主流文档 (说明书) 的描述 (摘录)

* 在官方 Solidity 文档的 “units and global variables” 部分，有如下说明 (对应较新 EVM 版本)：

> `selfdestruct(address payable recipient)` — Destroy the current contract, sending its funds to the given Address and end execution. 注意: 从 EVM ≥ Cancun 起，`selfdestruct` **仅发送合约里所有 Ether**，而**不再真正销毁合约**。 ([docs.soliditylang.org][9])

* 如果合约中调用 `selfdestruct`，接收地址如果是合约，其 `receive` / `fallback` 函数也不会被触发 — 也就是说这是一个强制转账 (forced transfer)，不会执行接收合约的逻辑。 ([docs.soliditylang.org][9])
* 官方文档关于智能合约 (contracts) 的部分，也将合约定义为包含“状态 (state variables)”和“函数 (functions)”——当合约被销毁 (历史行为) 时，这些内容都将被移除。 ([docs.soliditylang.org][11])

---

## 🧑‍💻 对开发者 / 使用者的重要提醒

鉴于上述，作为开发者或审计者／使用者，需要注意：

* **不要依赖 `selfdestruct` 保证合约“永久销毁”** —— 在新 EVM (Cancun 之后) 下，它不再删除代码/存储，只转移 Ether。
* **如果真的需要释放合约、废弃合约**，考虑其他设计方案 (比如通过逻辑层控制合约不再响应 calls、或使用更安全、明确的“迁移 +弃用”机制)，而不是 `selfdestruct`。
* **避免给公众接口 (public) 提供无权限控制的 `selfdestruct`** — 否则很容易被滥用造成资金或功能损失。
* **审计已经部署合约** — 检查是否包含 `selfdestruct`，它是否可能被滥用或触发；特别是库合约 /共有合约 /代理合约 (proxy) 架构。
* **关注未来 EVM / 升级 /规范 (EIP)**，因为 `SELFDESTRUCT` 的行为还可能继续调整 (或最终废弃)。

---
